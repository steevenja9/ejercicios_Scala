JAIME STEEVEN PUERTA MARTINEZ                                 UNIVERSIDAD DE HUELVA

                                                          MODELOS AVANZADOS DE COMPUTACION
DIFERENCIAS ENTRE HASKEL Y SCALA

HASKEL
1)Puramente funcional: 
No hay pautas, solo expresiones que no pueden mutar variables (locales o globales) ni acceder a estados como tiempo o números aleatorios.

2)Haskell tiene la característica principal de la evaluación perezosa. Asimismo, se denomina "llamada por necesidad", que es una estrategia en la que el desarrollador
puede aplazar la evaluación de una expresión hasta que se requiera o solicite su valor. Ayuda a evitar evaluaciones repetidas que potencian el intercambio, lo que reduce 
el tiempo de ejecución de las funciones.

3) Haskell es de código abierto, con una amplia gama de paquetes disponibles en los servidores públicos. Por ejemplo, base, parsec, etc.
4)Tipado estáticamente: en Haskell, el tipo de cada expresión se determina en el momento de la compilación. Todos los tipos compuestos juntos por aplicación de función deben 
estar coordinados o emparejados. En caso de que, si no coinciden, el compilador descartará el programa.
Inferencia de tipos: las clases de tipos son las características más impresionantes de Haskell, que permiten caracterizar interfaces genéricas. Son una gran idea dar una 
lista típica de características de diferentes tipos. Las características como calidad, pruebas y operadores numéricos utilizan las clases de Tipo

SCALA
1)Funcional: también es un lenguaje de programación funcional, ya que cada función es un valor y cada valor es un objeto. Proporciona soporte para funciones de orden superior,
funciones anidadas, funciones anónimas, etc.
2)Inferencia de tipo: en Scala, no es necesario mencionar el tipo de datos y los tipos de retorno de función explícitamente, deduce automáticamente el tipo de datos. 
El tipo de función devuelto se estima por el tipo de última expresión presente en la función.
3)Inmutabilidad: Scala usa la idea de inmutabilidad en la que cada variable declarada es inmutable por supuesto. Inmutable significa que no puede modificar su valor.
Los datos inmutables ayudan a administrar el control de concurrencia que requiere la administración de datos. Además, podemos crear variables mutables cuyos valores 
se pueden cambiar o alterar.
4)Orientado a objetos: cada valor en Scala es un objeto, por lo que es un lenguaje de programación puramente orientado a objetos. El comportamiento y el tipo de objetos 
están representados por las clases y rasgos en Scala.
5)Ejecutar en JVM y puede ejecutar código Java: Java y Scala tienen un entorno de ejecución común. Por lo que el usuario puede pasar fácilmente de Java a Scala.
El compilador Scala compila el programa en un archivo .class, que contiene el código de bytes que puede ejecutar la JVM.

TRADUCCION DE EJERCICIOS DE HASKEL A SCALA       




/*S2. Traductor Haskell*/

traduce x = case x of
  1 -> "A"
  2 -> "B"
  3 -> "C"
  otherwise -> "X"
  
  
/*S2. Traductor scala*/

def traduce(x: Double): String = {
  
   x match {
  case 1 => "A"
  case 2 => "B"
  case 3 => "C"
  case 4 => "A"
  case _ => "X"
  }

}               
===========================================================================================================================================================================

/*S2. suma Haskell*/
suma:: Num a => a -> a -> a -> a
suma x y z = x + y + z

-- suma2:: Double -> Double -> Double
suma2 :: (Fractional a, Fractional b) => a -> b -> b -> b
suma2 1.0 y z = 1.0 + y + z

-- suma3::Integer -> Integer
suma3 :: (Num a, Num b, Num c) => a -> b -> c -> c
suma3 1 2 z = 1 + 2 + z



/*S2. suma scala*/
val b= 1.0  val z = 1.5555  
val c= 3.0 
def suma(x: Double, y: Double): Double = x + y 
suma(b,c)                                         //> res1: Double = 4.0
def suma3(x: Double, y: Double,z: Double) : Double = x + y + z
suma3(b,c,z)                                      //> res2: Double = 5.5555

===========================================================================================================================================================================



/*S2. divisible Haskell*/
divisible::Int->Int->Bool
divisible x y = resto == 0
  where resto = mod x y
  
  
 def divisible(div: Int, divisor: Int): Boolean = {
 if( div % divisor ==0 ) true
 else false
 }                                                //> divisible: (div: Int, divisor: Int)Boolean
    divisible(4,2)                                //> res6: Boolean = true
    
===========================================================================================================================================================================
/*S2. factorial Haskell*/
factorial :: Integer -> Integer
-- factorial :: Num a => a -> a
factorial 0 = 1
factorial n = n * factorial (n - 1)

/*S2. factorial scala*/
def factorial(n: Int): Int = {  
        var f = 1
        for(i <- 1 to n)
        {
            f = f * i;
        }
        return f
    }                                             //> factorial: (n: Int)Int
    factorial(5)                                 //> res4: Int = 120

factorial2 :: (Num a, Ord a) => a -> a
factorial2 n
  |n == 0 = 1
  |n > 0 = n * factorial2 ( n - 1)
  |otherwise = error "valor negativo"


 ===================================================================================================================================== 
  LISTAS SCALA
  
/* añadir un elementos al principio de la lista */
scala> val l3 = 4 :: l2
l3: List[Int] = List(4, 1, 2, 3)

/+ concatenar listas */
List = List :+ List2

/* añadir n elementos a la lista */
scala> List.fill(3)("foo")
res1: List[String] = List(foo, foo, foo)


/*recorrer lista*/
var i=0
for(x <- lista){
i +=1;
}
======================================================================================================================================
val list2 = List(1.0,2.0,3.0,4.0,5.0)             //> list2  : List[Double] = List(1.0, 2.0, 3.0, 4.0, 5.0)
val list = List (5.0,3.0,1.0,2.0,4.0)             //> list  : List[Double] = List(5.0, 3.0, 1.0, 2.0, 4.0)

def mifuncion(lis: List[Double], lis2: List[Double]= List(0,0) ) = {

if(lis.length<lis2.length)
lis :+ List.fill(lis2.length-lis.length)(0)
else
lis2 :+ List.fill(lis.length-lis2.length)(0)
 
 
var dev: List[Double] = List()
var i=0
for(x <- lis){
dev = dev :+ lis2(i)+x
i +=1
}
dev
}                                                 //> mifuncion: (lis: List[Double], lis2: List[Double])List[Double]
mifuncion(list,list2)                             //> res0: List[Double] = List(6.0, 5.0, 4.0, 6.0, 9.0)




  
  
